"""
Auto-generates project_map.md by scanning the GeomechML codebase.

This script creates comprehensive documentation of the project structure,
including Python and Octave files, their purposes, and relationships.
Octave files are used for reservoir simulation with MRST.
"""

import os
import re
import ast
from typing import Dict, List, Optional, Tuple
from pathlib import Path
from datetime import datetime

# Configure project root and output
PROJECT_ROOT = Path(__file__).parent.parent
OUTPUT_FILE = PROJECT_ROOT / "docs" / "project_map.md"

# Target directories to document
TARGET_DIRS = ["mrst_simulation_scripts", "tests", "monitoring"]

# File extensions to process
EXTENSIONS = {
    ".py": "Python",
    ".m": "Octave"
}

def extract_python_docstring(filepath: Path) -> Optional[str]:
    """Extract module-level docstring from Python file."""
    try:
        with open(filepath, 'r', encoding='utf-8') as f:
            content = f.read()
        
        tree = ast.parse(content)
        docstring = ast.get_docstring(tree)
        if docstring:
            return docstring.strip()
        return None
    except:
        return None

def extract_octave_docstring(filepath: Path) -> Optional[str]:
    """Extract module-level documentation from Octave file."""
    try:
        with open(filepath, 'r', encoding='utf-8') as f:
            lines = f.readlines()
        
        # Look for comment block at start of file
        docstring_lines = []
        in_docstring = False
        
        for line in lines:
            line = line.strip()
            if not line:
                continue
            
            # Start of comment block
            if line.startswith('%') and not in_docstring:
                in_docstring = True
                docstring_lines.append(line[1:].strip())
            # Continue comment block
            elif line.startswith('%') and in_docstring:
                docstring_lines.append(line[1:].strip())
            # End of comment block
            elif in_docstring and not line.startswith('%'):
                break
        
        if docstring_lines:
            return ' '.join(docstring_lines).strip()
        return None
    except:
        return None

def extract_functions(filepath: Path) -> List[str]:
    """Extract function names from Python or Octave file."""
    functions = []
    
    try:
        with open(filepath, 'r', encoding='utf-8') as f:
            content = f.read()
        
        if filepath.suffix == '.py':
            # Python functions
            tree = ast.parse(content)
            for node in ast.walk(tree):
                if isinstance(node, ast.FunctionDef):
                    functions.append(node.name)
        
        elif filepath.suffix == '.m':
            # Octave functions
            lines = content.splitlines()
            for line in lines:
                line = line.strip()
                # Match function declarations
                if line.startswith('function '):
                    # Extract function name
                    match = re.search(r'function\s+(?:\w+\s*=\s*)?(\w+)\s*\(', line)
                    if match:
                        functions.append(match.group(1))
    except:
        pass
    
    return functions

def classify_file_role(filepath: Path) -> str:
    """Classify file based on its path and content."""
    path_parts = filepath.parts
    
    # Role based on directory structure
    if 'test' in path_parts:
        return 'test'
    elif 'debug' in path_parts:
        return 'debug'
    elif 'sim_scripts' in path_parts:
        return 'simulation'
    elif 'src' in path_parts:
        if 'surrogate' in path_parts:
            return 'ml_model'
        elif 'utils' in path_parts:
            return 'utility'
        else:
            return 'core'
    elif 'docs' in path_parts:
        return 'documentation'
    
    # Default classification
    return 'utility'

def get_directory_description(directory: str) -> str:
    """Get description for each directory."""
    descriptions = {
        'sim_scripts': 'Octave simulation scripts using MRST for reservoir modeling',
        'src': 'Python source code for machine learning and data processing',
        'src/surrogate': 'Machine learning surrogate models and training scripts',
        'src/utils': 'Python utility functions and helper modules',
        'tests': 'Test files mirroring the source structure (Python and Octave)',
        'data': 'Data storage (raw simulation outputs and processed datasets)',
        'debug': 'Debug and experimental scripts (git-ignored)',
        'to_dos': 'Task tracking and TODO files generated by LLM',
        'plots': 'Visualization outputs and QA/QC plots',
        'docs': 'Project documentation in English and Spanish'
    }
    return descriptions.get(directory, 'Project files')

def scan_directory(directory: Path) -> Dict:
    """Scan directory and collect file information."""
    files_info = {}
    
    if not directory.exists():
        return files_info
    
    for filepath in directory.rglob('*'):
        if filepath.is_file() and filepath.suffix in EXTENSIONS:
            # Skip debug files
            if filepath.name.startswith('dbg_'):
                continue
            
            # Skip Octave temporary files
            if filepath.suffix in ['.asv', '.m~']:
                continue
            
            relative_path = filepath.relative_to(PROJECT_ROOT)
            
            # Extract documentation
            if filepath.suffix == '.py':
                docstring = extract_python_docstring(filepath)
            elif filepath.suffix == '.m':
                docstring = extract_octave_docstring(filepath)
            else:
                docstring = None
            
            # Extract functions
            functions = extract_functions(filepath)
            
            # File info
            files_info[str(relative_path)] = {
                'type': EXTENSIONS[filepath.suffix],
                'role': classify_file_role(relative_path),
                'docstring': docstring,
                'functions': functions,
                'size': filepath.stat().st_size
            }
    
    return files_info

def generate_project_map():
    """Generate the complete project map."""
    
    # Collect all files
    all_files = {}
    
    for dirname in TARGET_DIRS:
        dir_path = PROJECT_ROOT / dirname
        dir_files = scan_directory(dir_path)
        all_files.update(dir_files)
    
    # Generate markdown content
    content = f"""# GeomechML Project Map

*Auto-generated on {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}*

## Overview

This document provides a comprehensive map of the GeomechML project structure, including:
- **Octave simulation scripts** using MRST for reservoir modeling
- **Python machine learning** components for surrogate modeling
- **Test files** ensuring code quality and correctness
- **Documentation** and project organization

## Directory Structure

```
GeomechML/
├── sim_scripts/        # Octave simulation runners with MRST
├── src/               # Python ML/surrogate code
│   ├── surrogate/     # ML model implementations
│   └── utils/         # Python utilities
├── data/
│   ├── raw/          # Binary simulation outputs (*.mat)
│   └── processed/    # Processed datasets (*.csv)
├── tests/            # Test files mirroring source structure
├── debug/            # Debug scripts (git-ignored)
├── to_dos/           # LLM-generated task lists
├── plots/            # QA/QC visualization outputs
├── docs/
│   ├── English/      # English documentation
│   ├── Spanish/      # Spanish documentation
│   └── ADR/          # Architecture Decision Records
└── .cursor/rules/    # Cursor IDE rules
```

## File Catalog

"""
    
    # Group files by directory
    by_directory = {}
    for filepath, info in all_files.items():
        directory = str(Path(filepath).parent)
        if directory not in by_directory:
            by_directory[directory] = []
        by_directory[directory].append((filepath, info))
    
    # Generate content for each directory
    for directory in sorted(by_directory.keys()):
        files = by_directory[directory]
        
        content += f"\n### {directory}/\n\n"
        content += f"*{get_directory_description(directory)}*\n\n"
        
        for filepath, info in sorted(files):
            filename = Path(filepath).name
            
            content += f"**{filename}** ({info['type']})\n"
            
            if info['docstring']:
                content += f"- {info['docstring']}\n"
            
            if info['functions']:
                content += f"- Functions: {', '.join(info['functions'])}\n"
            
            content += f"- Role: {info['role']}\n"
            content += f"- Size: {info['size']} bytes\n\n"
    
    # Write to file
    with open(OUTPUT_FILE, 'w', encoding='utf-8') as f:
        f.write(content)

if __name__ == "__main__":
    generate_project_map() 
