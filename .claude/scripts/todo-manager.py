#!/usr/bin/env python3
"""
Daily TODO Management System for Claude Code

This script manages daily TODO files, task tracking, and productivity metrics
integrated with the Claude Code development workflow.
"""

import os
import sys
import json
import argparse
import logging
from datetime import datetime, timedelta
from pathlib import Path
from typing import Dict, List, Optional, Any
from dataclasses import dataclass, asdict
import re

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('/workspace/.claude/logs/todo-manager.log'),
        logging.StreamHandler()
    ]
)

logger = logging.getLogger('TodoManager')

# Constants
TODO_BASE_PATH = Path('/workspace/obsidian-vault/Planning/Todo_Lists')
TEMPLATE_PATH = TODO_BASE_PATH / 'templates' / 'daily_todo_template.md'
ARCHIVE_PATH = TODO_BASE_PATH / 'archive'
CONFIG_PATH = Path('/workspace/.claude/settings.local.json')


@dataclass
class TaskItem:
    """Individual task item with metadata."""
    content: str
    status: str  # pending, in_progress, completed, blocked, deferred
    created: datetime
    updated: datetime
    priority: str = "medium"  # high, medium, low
    estimated_time: Optional[int] = None  # minutes
    actual_time: Optional[int] = None  # minutes
    tags: List[str] = None
    notes: str = ""
    
    def __post_init__(self):
        if self.tags is None:
            self.tags = []


@dataclass
class TodoFile:
    """Daily TODO file representation."""
    date: datetime
    tasks: Dict[str, List[TaskItem]]
    focus_areas: Dict[str, str]
    notes: str
    metrics: Dict[str, Any]
    
    def __post_init__(self):
        if not self.tasks:
            self.tasks = {
                'pending': [],
                'in_progress': [],
                'completed': [],
                'blocked': [],
                'deferred': []
            }
        if not self.focus_areas:
            self.focus_areas = {
                'primary': '',
                'secondary': ''
            }
        if not self.metrics:
            self.metrics = {
                'total_tasks': 0,
                'completed': 0,
                'completion_rate': 0.0
            }


class TodoManager:
    """Main TODO management class."""
    
    def __init__(self, workspace_path: str = "/workspace"):
        self.workspace_path = Path(workspace_path)
        self.todo_path = TODO_BASE_PATH
        self.template_path = TEMPLATE_PATH
        self.archive_path = ARCHIVE_PATH
        
        # Ensure directories exist
        self.todo_path.mkdir(parents=True, exist_ok=True)
        self.archive_path.mkdir(parents=True, exist_ok=True)
        
        logger.info(f"TodoManager initialized with workspace: {workspace_path}")
    
    def get_todo_file_path(self, date: datetime) -> Path:
        """Get path for TODO file for given date."""
        return self.todo_path / f"{date.strftime('%Y-%m-%d')}.md"
    
    def load_template(self) -> str:
        """Load daily TODO template."""
        if not self.template_path.exists():
            logger.error(f"Template not found: {self.template_path}")
            return self._get_default_template()
        
        with open(self.template_path, 'r') as f:
            return f.read()
    
    def _get_default_template(self) -> str:
        """Get default template if file doesn't exist."""
        return """# Daily TODO - {{DATE}}

## ðŸ“‹ Tasks for Today

### â³ Pending

### ðŸ”„ In Progress

### âœ… Completed

## ðŸ“ Notes

---
*Generated by Claude Code TODO System*
"""
    
    def create_daily_todo(self, date: datetime, rollover: bool = True) -> bool:
        """Create new daily TODO file."""
        file_path = self.get_todo_file_path(date)
        
        # Check if file already exists
        if file_path.exists():
            logger.info(f"TODO file already exists: {file_path}")
            return True
        
        # Load template
        template_content = self.load_template()
        
        # Replace template variables
        content = template_content.replace('{{DATE}}', date.strftime('%Y-%m-%d'))
        content = content.replace('{{DAY_OF_WEEK}}', date.strftime('%A'))
        content = content.replace('{{TIMESTAMP}}', datetime.now().strftime('%Y-%m-%d %H:%M:%S'))
        
        # Handle rollover from yesterday
        if rollover:
            yesterday = date - timedelta(days=1)
            rollover_tasks = self._get_rollover_tasks(yesterday)
            if rollover_tasks:
                content = self._insert_rollover_tasks(content, rollover_tasks)
        
        # Write file
        try:
            with open(file_path, 'w') as f:
                f.write(content)
            logger.info(f"Created TODO file: {file_path}")
            return True
        except Exception as e:
            logger.error(f"Failed to create TODO file: {e}")
            return False
    
    def _get_rollover_tasks(self, date: datetime) -> List[str]:
        """Get incomplete tasks from previous day."""
        file_path = self.get_todo_file_path(date)
        
        if not file_path.exists():
            return []
        
        try:
            with open(file_path, 'r') as f:
                content = f.read()
            
            # Extract pending and in-progress tasks
            rollover_tasks = []
            
            # Simple regex to find tasks under Pending and In Progress sections
            pending_section = re.search(r'### â³ Pending\s*\n(.*?)(?=###|\Z)', content, re.DOTALL)
            in_progress_section = re.search(r'### ðŸ”„ In Progress\s*\n(.*?)(?=###|\Z)', content, re.DOTALL)
            
            for section in [pending_section, in_progress_section]:
                if section:
                    tasks = re.findall(r'^- (.+)$', section.group(1), re.MULTILINE)
                    rollover_tasks.extend(tasks)
            
            logger.info(f"Found {len(rollover_tasks)} tasks to rollover from {date.strftime('%Y-%m-%d')}")
            return rollover_tasks
            
        except Exception as e:
            logger.error(f"Failed to get rollover tasks: {e}")
            return []
    
    def _insert_rollover_tasks(self, content: str, tasks: List[str]) -> str:
        """Insert rollover tasks into new TODO file."""
        if not tasks:
            return content
        
        # Add rollover section
        rollover_section = "\n### ðŸ”„ Carried Over from Yesterday\n"
        for task in tasks:
            rollover_section += f"- {task}\n"
        rollover_section += "\n"
        
        # Insert after Pending section
        content = content.replace('### â³ Pending\n', f'### â³ Pending\n{rollover_section}')
        
        return content
    
    def get_todo_status(self, date: datetime) -> Dict[str, Any]:
        """Get status summary for given date."""
        file_path = self.get_todo_file_path(date)
        
        if not file_path.exists():
            return {
                'date': date.strftime('%Y-%m-%d'),
                'exists': False,
                'message': 'No TODO file found for this date'
            }
        
        try:
            with open(file_path, 'r') as f:
                content = f.read()
            
            # Parse tasks from content
            stats = self._parse_task_stats(content)
            
            return {
                'date': date.strftime('%Y-%m-%d'),
                'exists': True,
                'file_path': str(file_path),
                'stats': stats,
                'summary': self._generate_summary(stats)
            }
            
        except Exception as e:
            logger.error(f"Failed to get TODO status: {e}")
            return {
                'date': date.strftime('%Y-%m-%d'),
                'exists': True,
                'error': str(e)
            }
    
    def _parse_task_stats(self, content: str) -> Dict[str, Any]:
        """Parse task statistics from TODO content."""
        stats = {
            'pending': 0,
            'in_progress': 0,
            'completed': 0,
            'blocked': 0,
            'total': 0,
            'completion_rate': 0.0
        }
        
        # Count tasks in each section
        sections = {
            'pending': r'### â³ Pending\s*\n(.*?)(?=###|\Z)',
            'in_progress': r'### ðŸ”„ In Progress\s*\n(.*?)(?=###|\Z)',
            'completed': r'### âœ… Completed\s*\n(.*?)(?=###|\Z)',
            'blocked': r'### ðŸš« Blocked\s*\n(.*?)(?=###|\Z)'
        }
        
        for section_name, pattern in sections.items():
            section_match = re.search(pattern, content, re.DOTALL)
            if section_match:
                tasks = re.findall(r'^- (.+)$', section_match.group(1), re.MULTILINE)
                stats[section_name] = len(tasks)
        
        # Calculate totals
        stats['total'] = sum(stats[key] for key in ['pending', 'in_progress', 'completed', 'blocked'])
        
        if stats['total'] > 0:
            stats['completion_rate'] = round((stats['completed'] / stats['total']) * 100, 1)
        
        return stats
    
    def _generate_summary(self, stats: Dict[str, Any]) -> str:
        """Generate human-readable summary from stats."""
        if stats['total'] == 0:
            return "No tasks found for this date"
        
        summary_parts = []
        
        # Basic stats
        summary_parts.append(f"Total tasks: {stats['total']}")
        summary_parts.append(f"Completed: {stats['completed']} ({stats['completion_rate']}%)")
        
        # In progress
        if stats['in_progress'] > 0:
            summary_parts.append(f"In progress: {stats['in_progress']}")
        
        # Pending
        if stats['pending'] > 0:
            summary_parts.append(f"Pending: {stats['pending']}")
        
        # Blocked
        if stats['blocked'] > 0:
            summary_parts.append(f"Blocked: {stats['blocked']}")
        
        return " | ".join(summary_parts)
    
    def show_todo_file(self, date: datetime, format_type: str = "markdown") -> str:
        """Show TODO file content for given date."""
        file_path = self.get_todo_file_path(date)
        
        if not file_path.exists():
            return f"No TODO file found for {date.strftime('%Y-%m-%d')}"
        
        try:
            with open(file_path, 'r') as f:
                content = f.read()
            
            if format_type == "plain":
                # Strip markdown formatting
                content = re.sub(r'^#+\s*', '', content, flags=re.MULTILINE)
                content = re.sub(r'\*\*(.*?)\*\*', r'\1', content)
                content = re.sub(r'__(.*?)__', r'\1', content)
            
            return content
            
        except Exception as e:
            logger.error(f"Failed to read TODO file: {e}")
            return f"Error reading TODO file: {e}"
    
    def archive_old_files(self, older_than_days: int = 30) -> Dict[str, Any]:
        """Archive TODO files older than specified days."""
        cutoff_date = datetime.now() - timedelta(days=older_than_days)
        archived_files = []
        
        # Find files to archive
        for file_path in self.todo_path.glob("*.md"):
            if file_path.name.startswith("202"):  # Date format files
                try:
                    file_date = datetime.strptime(file_path.stem, "%Y-%m-%d")
                    if file_date < cutoff_date:
                        # Create archive directory structure
                        archive_dir = self.archive_path / str(file_date.year) / f"{file_date.month:02d}"
                        archive_dir.mkdir(parents=True, exist_ok=True)
                        
                        # Move file
                        archive_file = archive_dir / file_path.name
                        file_path.rename(archive_file)
                        archived_files.append(str(archive_file))
                        
                except ValueError:
                    # Skip files that don't match date format
                    continue
        
        logger.info(f"Archived {len(archived_files)} files older than {older_than_days} days")
        
        return {
            'archived_count': len(archived_files),
            'archived_files': archived_files,
            'cutoff_date': cutoff_date.strftime('%Y-%m-%d')
        }


def main():
    """Main CLI interface."""
    parser = argparse.ArgumentParser(description='Daily TODO Management System')
    parser.add_argument('command', choices=['status', 'create', 'show', 'archive', 'rollover'],
                       help='Command to execute')
    parser.add_argument('--date', type=str, help='Date in YYYY-MM-DD format (default: today)')
    parser.add_argument('--rollover', action='store_true', help='Include rollover from previous day')
    parser.add_argument('--older-than', type=int, default=30, help='Archive files older than N days')
    parser.add_argument('--format', choices=['markdown', 'json', 'plain'], default='markdown',
                       help='Output format')
    parser.add_argument('--verbose', action='store_true', help='Verbose output')
    
    args = parser.parse_args()
    
    # Set logging level
    if args.verbose:
        logging.getLogger().setLevel(logging.DEBUG)
    
    # Parse date
    if args.date:
        try:
            target_date = datetime.strptime(args.date, '%Y-%m-%d')
        except ValueError:
            print(f"Error: Invalid date format. Use YYYY-MM-DD")
            sys.exit(1)
    else:
        target_date = datetime.now()
    
    # Initialize manager
    manager = TodoManager()
    
    # Execute command
    try:
        if args.command == 'status':
            status = manager.get_todo_status(target_date)
            if args.format == 'json':
                print(json.dumps(status, indent=2))
            else:
                print(f"ðŸ“… TODO Status for {status['date']}")
                if status['exists']:
                    print(f"ðŸ“„ File: {status.get('file_path', 'N/A')}")
                    print(f"ðŸ“Š Summary: {status.get('summary', 'No summary available')}")
                else:
                    print(f"âŒ {status['message']}")
                    print(f"ðŸ’¡ Run '/todo create' to create today's TODO file")
        
        elif args.command == 'create':
            success = manager.create_daily_todo(target_date, rollover=args.rollover)
            if success:
                print(f"âœ… Created TODO file for {target_date.strftime('%Y-%m-%d')}")
                if args.rollover:
                    print("ðŸ”„ Included rollover tasks from previous day")
            else:
                print(f"âŒ Failed to create TODO file")
                sys.exit(1)
        
        elif args.command == 'show':
            content = manager.show_todo_file(target_date, args.format)
            print(content)
        
        elif args.command == 'archive':
            result = manager.archive_old_files(args.older_than)
            print(f"ðŸ“¦ Archived {result['archived_count']} files older than {args.older_than} days")
            if args.verbose and result['archived_files']:
                print("Archived files:")
                for file_path in result['archived_files']:
                    print(f"  - {file_path}")
        
        elif args.command == 'rollover':
            yesterday = target_date - timedelta(days=1)
            success = manager.create_daily_todo(target_date, rollover=True)
            if success:
                print(f"ðŸ”„ Rolled over tasks from {yesterday.strftime('%Y-%m-%d')} to {target_date.strftime('%Y-%m-%d')}")
            else:
                print("âŒ Failed to perform rollover")
                sys.exit(1)
    
    except Exception as e:
        logger.error(f"Command execution failed: {e}")
        print(f"âŒ Error: {e}")
        sys.exit(1)


if __name__ == '__main__':
    main()